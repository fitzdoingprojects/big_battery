C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  12/18/2018 21:39:41 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE BIG_BATTERY_MAIN
OBJECT MODULE PLACED IN .\src/big_battery_main.OBJ
COMPILER INVOKED BY: Z:\home\fitz\Downloads\SimplicityStudio_v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe /media/f
                    -itz/data/dropbox/projects/ee/big_battery/firmware/big_battery/src/big_battery_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(L
                    -ARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SIZE) INTVECTOR(0X0000) INTPROMOTE INCDIR(/media/fitz/data/dropbox/projec
                    -ts/ee/big_battery/firmware/big_battery/inc;/home/fitz/Downloads/SimplicityStudio_v4/developer/sdks/8051/v4.1.5//Device/s
                    -hared/si8051Base;/home/fitz/Downloads/SimplicityStudio_v4/developer/sdks/8051/v4.1.5//Device/EFM8BB1/inc) PRINT(.\src/bi
                    -g_battery_main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/big_battery_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/big_battery_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
  13          #include "InitDevice.h"
  14          // $[Generated Includes]
  15          // [Generated Includes]$
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global CONSTANTS
  19          //-----------------------------------------------------------------------------
  20          #define DEV_NAME "1"
  21          
  22          
  23          SI_SBIT(TRICKLE_DIS, SFR_P0, 2);               // P0.2 Trickle Disable
  24          SI_SBIT(OUTPUT_EN, SFR_P0, 7);               // P0.7 Output Enable
  25          
  26          typedef enum {
  27              ADC0_POSITIVE_INPUT_P0, //!< ADC0P0 is ADC Positive Input
  28              ADC0_POSITIVE_INPUT_P1, //!< ADC0P1 is ADC Positive Input
  29              ADC0_POSITIVE_INPUT_P2, //!< ADC0P2 is ADC Positive Input
  30              ADC0_POSITIVE_INPUT_P3, //!< ADC0P3 is ADC Positive Input
  31              ADC0_POSITIVE_INPUT_P4, //!< ADC0P4 is ADC Positive Input
  32              ADC0_POSITIVE_INPUT_P5, //!< ADC0P5 is ADC Positive Input
  33              ADC0_POSITIVE_INPUT_P6, //!< ADC0P6 is ADC Positive Input
  34              ADC0_POSITIVE_INPUT_P7, //!< ADC0P7 is ADC Positive Input
  35              ADC0_POSITIVE_INPUT_P8, //!< ADC0P8 is ADC Positive Input
  36              ADC0_POSITIVE_INPUT_P9, //!< ADC0P9 is ADC Positive Input
  37              ADC0_POSITIVE_INPUT_P10, //!< ADC0P10 is ADC Positive Input
  38              ADC0_POSITIVE_INPUT_P11, //!< ADC0P11 is ADC Positive Input
  39              ADC0_POSITIVE_INPUT_P12, //!< ADC0P12 is ADC Positive Input
  40              ADC0_POSITIVE_INPUT_P13, //!< ADC0P13 is ADC Positive Input
  41              ADC0_POSITIVE_INPUT_P14, //!< ADC0P14 is ADC Positive Input
  42              ADC0_POSITIVE_INPUT_P15, //!< ADC0P15 is ADC Positive Input
  43              ADC0_POSITIVE_INPUT_TEMP, //!< Internal Temperature Sensor is ADC Positive Input
  44              ADC0_POSITIVE_INPUT_LDO_OUT, //!< Internal 1.8 V LDO Output is ADC Positive Input
  45              ADC0_POSITIVE_INPUT_VDD, //!< VDD Supply Pin is ADC Positive Input
  46              ADC0_POSITIVE_INPUT_GND, //!< GND Supply Pin is ADC Positive Input
  47              ADC0_POSITIVE_INPUT_NONE = 31, //!< ADC Positive Input is disconnected
  48          }ADC0_PositiveInput_t;
  49          
  50          #define VOLTAGE_ADC ADC0_POSITIVE_INPUT_P0
  51          #define CURRENT_ADC ADC0_POSITIVE_INPUT_P1
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  12/18/2018 21:39:41 PAGE 2   

  52          #define TEMP_ADC ADC0_POSITIVE_INPUT_TEMP
  53          
  54          //-----------------------------------------------------------------------------
  55          // Externs
  56          //-----------------------------------------------------------------------------
  57          extern uint8_t TX_BUFFER[UART_BUFFERSIZE];
  58          extern uint8_t RX_BUFFER[UART_BUFFERSIZE];
  59          extern uint8_t TX_index;
  60          extern uint8_t TX_size;
  61          extern uint8_t RX_size;
  62          extern uint8_t RX_recieved;
  63          extern uint8_t UART_Output_First;
  64          extern uint8_t TX_Ready;
  65          extern uint8_t Byte;
  66          
  67          void uart_write(char * buf, uint8_t size);
  68          void uart_write16(uint16_t val);
  69          void set_pwm0(uint16_t duty);
  70          void set_pwm1(uint16_t duty);
  71          uint16_t poll_adc(uint16_t channel);
  72          
  73          uint16_t ADC0_getResult(void);
  74          bool ADC0_isConversionComplete(void);
  75          void ADC0_startConversion(void);
  76          void ADC0_setPositiveInput(ADC0_PositiveInput_t input);
  77          
  78          
  79          
  80          
  81          //-----------------------------------------------------------------------------
  82          // SiLabs_Startup() Routine
  83          // ----------------------------------------------------------------------------
  84          // This function is called immediately after reset, before the initialization
  85          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  86          // useful place to disable the watchdog timer, which is enable by default
  87          // and may trigger before main() in some instances.
  88          //-----------------------------------------------------------------------------
  89          void SiLabs_Startup (void)
  90          {
  91   1        // $[SiLabs Startup]
  92   1        // [SiLabs Startup]$
  93   1      }
  94          
  95          //-----------------------------------------------------------------------------
  96          // main() Routine
  97          // ----------------------------------------------------------------------------
  98          int main (void) {
  99   1              // Call hardware initialization routine
 100   1              uint16_t val = 0;
 101   1              enter_DefaultMode_from_RESET();
 102   1      
 103   1              TRICKLE_DIS = 1;
 104   1              OUTPUT_EN = 1;
 105   1      
 106   1              set_pwm0(0);
 107   1              set_pwm1(0);
 108   1      
 109   1              uart_write(DEV_NAME, 1);
 110   1              uart_write("\nSTART\n", 5);
 111   1      
 112   1              while(1) {
 113   2                      if(RX_recieved && RX_BUFFER[0]) {
 114   3      
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  12/18/2018 21:39:41 PAGE 3   

 115   3                              if(RX_size == 4 && RX_BUFFER[1] == 'R' ) {
 116   4      
 117   4                                      uart_write(DEV_NAME, 1);
 118   4      
 119   4                                      switch(RX_BUFFER[2]) {
 120   5                                      case 'V':
 121   5                                              uart_write("V", 1);
 122   5                                              uart_write16(poll_adc(VOLTAGE_ADC));
 123   5                                              uart_write("\nACK\n", 5);
 124   5                                              break;
 125   5                                      case 'I':
 126   5                                              uart_write("I", 1);
 127   5                                              uart_write16(poll_adc(CURRENT_ADC));
 128   5                                              uart_write("\nACK\n", 5);
 129   5                                              break;
 130   5                                      case 'T':
 131   5                                              uart_write("T", 1);
 132   5                                              uart_write16(poll_adc(TEMP_ADC));
 133   5                                              uart_write("\nACK\n", 5);
 134   5                                              break;
 135   5                                      }
 136   4                              }
 137   3                              if(RX_size == 6 && RX_BUFFER[1] == 'T' ) {
 138   4      
 139   4                                      uart_write(DEV_NAME, 1);
 140   4      
 141   4                                      val = (((uint16_t) RX_BUFFER[3]) << 8) & 0xFF00;
 142   4                                      val |= 0x00FF & RX_BUFFER[4];
 143   4                                      switch(RX_BUFFER[2]) {
 144   5                                      case 'V': //NOTE: BE CAREFUL OF OVERFLOW, PWM is 11bits
 145   5                                              set_pwm0(val);
 146   5                                              uart_write16(val);
 147   5                                              uart_write("ACK\n", 5);
 148   5                                              break; //NOTE: BE CAREFUL OF OVERFLOW, PWM is 11bits
 149   5                                      case 'I':
 150   5                                              val = val >> 6;
 151   5                                              set_pwm1(val);
 152   5                                              uart_write16(val);
 153   5                                              uart_write("ACK\n", 5);
 154   5                                              break;
 155   5                                      case 'T':
 156   5                                              if(val == 0) {
 157   6                                                      TRICKLE_DIS = 0;
 158   6                                              } else {
 159   6                                                      TRICKLE_DIS = 1;
 160   6                                              }
 161   5                                              uart_write("ACK\n", 5);
 162   5                                              break;
 163   5                                      case 'E':
 164   5                                              if(val == 0) {
 165   6                                                      OUTPUT_EN = 0;
 166   6                                              } else {
 167   6                                                      OUTPUT_EN = 1;
 168   6                                              }
 169   5                                              uart_write("ACK\n", 5);
 170   5                                              break;
 171   5                                      }
 172   4                              }
 173   3                              //uart_write(RX_BUFFER, RX_size);
 174   3                              RX_recieved = 0;
 175   3                              RX_size = 0;
 176   3                      }
 177   2              }
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  12/18/2018 21:39:41 PAGE 4   

 178   1      }
 179          
 180          void uart_write16(uint16_t val) {
 181   1              TX_Ready = 0;
 182   1              TX_size = 2;
 183   1              TX_BUFFER[1] = (uint8_t) (val & 0x00FF);
 184   1              SBUF0 = (uint8_t) (val >> 8) & 0x00FF;
 185   1              while(!TX_Ready);
 186   1      }
 187          
 188          void uart_write(char * buf, uint8_t size) {
 189   1              TX_Ready = 0;
 190   1              TX_size = 0;
 191   1              while((TX_size < size) && (TX_size < UART_BUFFERSIZE)) {
 192   2                      TX_BUFFER[TX_size] = buf[TX_size];
 193   2                      TX_size++;
 194   2              }
 195   1              SBUF0 = TX_BUFFER[0];
 196   1              while(!TX_Ready);
 197   1      }
 198          
 199          void set_pwm0(uint16_t duty) {
 200   1              duty = duty % (1 << 11);
 201   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 202   1      
 203   1         PCA0CPL0 = (duty & 0x00FF);
 204   1         PCA0CPH0 = (duty & 0xFF00)>>8;
 205   1      
 206   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers              // Target PCA0CPH/L regi
             -sters
 207   1      }
 208          
 209          void set_pwm1(uint16_t duty) {
 210   1              duty = duty % (1 << 11);
 211   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 212   1      
 213   1         PCA0CPL1 = (duty & 0x00FF);
 214   1         PCA0CPH1 = (duty & 0xFF00)>>8;
 215   1      
 216   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers
 217   1      }
 218          
 219          
 220          void ADC0_setPositiveInput(ADC0_PositiveInput_t input)
 221          {
 222   1              // Turn on the temp sensor if it is the input
 223   1        if (input == ADC0_POSITIVE_INPUT_TEMP)
 224   1        {
 225   2          REF0CN |= 0x04;
 226   2        }
 227   1        else
 228   1        {
 229   2          REF0CN &= 0xFB;
 230   2        }
 231   1      
 232   1      
 233   1              ADC0MX = input;
 234   1      }
 235          
 236          void ADC0_startConversion(void)
 237          {
 238   1              uint8_t ADCM_save;
 239   1      
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  12/18/2018 21:39:41 PAGE 5   

 240   1              // Save the conversion source and set to ADBUSY
 241   1              ADCM_save = ADC0CN0 & ADC0CN0_ADCM__FMASK;
 242   1              ADC0CN0 = (ADC0CN0 & ~ADC0CN0_ADCM__FMASK) | ADC0CN0_ADCM__ADBUSY;
 243   1      
 244   1              // Clear the conversion complete flag
 245   1              ADC0CN0_ADINT = 0;
 246   1      
 247   1              // Start a conversion by setting ADBUSY
 248   1              ADC0CN0_ADBUSY = 1;
 249   1      
 250   1              // Restore the conversion source
 251   1              ADC0CN0 |= ADCM_save;
 252   1      }
 253          
 254          bool ADC0_isConversionComplete(void)
 255          {
 256   1              bool conversionComplete;
 257   1              conversionComplete = ADC0CN0_ADINT;
 258   1              return conversionComplete;
 259   1      }
 260          
 261          uint16_t ADC0_getResult(void)
 262          {
 263   1              uint16_t result;
 264   1              result = ADC0;
 265   1              return result;
 266   1      }
 267          
 268          //blocking
 269          uint16_t poll_adc(uint16_t channel) {
 270   1              ADC0_setPositiveInput(channel);
 271   1              ADC0_startConversion();
 272   1              while(!ADC0_isConversionComplete());
 273   1              return ADC0_getResult();
 274   1      }
 275          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    436    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

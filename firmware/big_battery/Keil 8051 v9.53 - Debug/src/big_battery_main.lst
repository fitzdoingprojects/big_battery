C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/07/2019 10:34:29 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE BIG_BATTERY_MAIN
OBJECT MODULE PLACED IN .\src/big_battery_main.OBJ
COMPILER INVOKED BY: Z:\home\fitz\Downloads\SimplicityStudio_v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe /media/f
                    -itz/data/dropbox/projects/ee/big_battery/firmware/big_battery/src/big_battery_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(L
                    -ARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SIZE) INTVECTOR(0X0000) INTPROMOTE INCDIR(/media/fitz/data/dropbox/projec
                    -ts/ee/big_battery/firmware/big_battery/inc;/home/fitz/Downloads/SimplicityStudio_v4/developer/sdks/8051/v4.1.5//Device/s
                    -hared/si8051Base;/home/fitz/Downloads/SimplicityStudio_v4/developer/sdks/8051/v4.1.5//Device/EFM8BB1/inc) PRINT(.\src/bi
                    -g_battery_main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/big_battery_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/big_battery_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
  13          #include "InitDevice.h"
  14          // $[Generated Includes]
  15          // [Generated Includes]$
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global CONSTANTS
  19          //-----------------------------------------------------------------------------
  20          #define DEV_NAME "1"
  21          
  22          
  23          SI_SBIT(TRICKLE_DIS, SFR_P0, 2);               // P0.2 Trickle Disable
  24          SI_SBIT(OUTPUT_EN, SFR_P0, 7);               // P0.7 Output Enable
  25          
  26          typedef enum {
  27              ADC0_POSITIVE_INPUT_P0, //!< ADC0P0 is ADC Positive Input
  28              ADC0_POSITIVE_INPUT_P1, //!< ADC0P1 is ADC Positive Input
  29              ADC0_POSITIVE_INPUT_P2, //!< ADC0P2 is ADC Positive Input
  30              ADC0_POSITIVE_INPUT_P3, //!< ADC0P3 is ADC Positive Input
  31              ADC0_POSITIVE_INPUT_P4, //!< ADC0P4 is ADC Positive Input
  32              ADC0_POSITIVE_INPUT_P5, //!< ADC0P5 is ADC Positive Input
  33              ADC0_POSITIVE_INPUT_P6, //!< ADC0P6 is ADC Positive Input
  34              ADC0_POSITIVE_INPUT_P7, //!< ADC0P7 is ADC Positive Input
  35              ADC0_POSITIVE_INPUT_P8, //!< ADC0P8 is ADC Positive Input
  36              ADC0_POSITIVE_INPUT_P9, //!< ADC0P9 is ADC Positive Input
  37              ADC0_POSITIVE_INPUT_P10, //!< ADC0P10 is ADC Positive Input
  38              ADC0_POSITIVE_INPUT_P11, //!< ADC0P11 is ADC Positive Input
  39              ADC0_POSITIVE_INPUT_P12, //!< ADC0P12 is ADC Positive Input
  40              ADC0_POSITIVE_INPUT_P13, //!< ADC0P13 is ADC Positive Input
  41              ADC0_POSITIVE_INPUT_P14, //!< ADC0P14 is ADC Positive Input
  42              ADC0_POSITIVE_INPUT_P15, //!< ADC0P15 is ADC Positive Input
  43              ADC0_POSITIVE_INPUT_TEMP, //!< Internal Temperature Sensor is ADC Positive Input
  44              ADC0_POSITIVE_INPUT_LDO_OUT, //!< Internal 1.8 V LDO Output is ADC Positive Input
  45              ADC0_POSITIVE_INPUT_VDD, //!< VDD Supply Pin is ADC Positive Input
  46              ADC0_POSITIVE_INPUT_GND, //!< GND Supply Pin is ADC Positive Input
  47              ADC0_POSITIVE_INPUT_NONE = 31, //!< ADC Positive Input is disconnected
  48          }ADC0_PositiveInput_t;
  49          
  50          #define VOLTAGE_ADC ADC0_POSITIVE_INPUT_P0
  51          #define CURRENT_ADC ADC0_POSITIVE_INPUT_P1
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/07/2019 10:34:29 PAGE 2   

  52          #define TEMP_ADC ADC0_POSITIVE_INPUT_TEMP
  53          
  54          //-----------------------------------------------------------------------------
  55          // Externs
  56          //-----------------------------------------------------------------------------
  57          extern uint8_t TX_BUFFER[UART_BUFFERSIZE];
  58          extern uint8_t RX_BUFFER[UART_BUFFERSIZE];
  59          extern uint8_t TX_index;
  60          extern uint8_t TX_size;
  61          extern uint8_t RX_size;
  62          extern uint8_t RX_recieved;
  63          extern uint8_t UART_Output_First;
  64          extern uint8_t TX_Ready;
  65          extern uint8_t Byte;
  66          
  67          void uart_write(char * buf, uint8_t size);
  68          void uart_write16(uint16_t val);
  69          void set_pwm0(uint16_t duty);
  70          void set_pwm1(uint16_t duty);
  71          uint16_t poll_adc(uint16_t channel);
  72          
  73          uint16_t ADC0_getResult(void);
  74          bool ADC0_isConversionComplete(void);
  75          void ADC0_startConversion(void);
  76          void ADC0_setPositiveInput(ADC0_PositiveInput_t input);
  77          
  78          
  79          
  80          
  81          //-----------------------------------------------------------------------------
  82          // SiLabs_Startup() Routine
  83          // ----------------------------------------------------------------------------
  84          // This function is called immediately after reset, before the initialization
  85          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  86          // useful place to disable the watchdog timer, which is enable by default
  87          // and may trigger before main() in some instances.
  88          //-----------------------------------------------------------------------------
  89          void SiLabs_Startup (void)
  90          {
  91   1        // $[SiLabs Startup]
  92   1        // [SiLabs Startup]$
  93   1      }
  94          
  95          //-----------------------------------------------------------------------------
  96          // main() Routine
  97          // ----------------------------------------------------------------------------
  98          int main (void) {
  99   1              // Call hardware initialization routine
 100   1              uint16_t val = 0;
 101   1              enter_DefaultMode_from_RESET();
 102   1      
 103   1              TRICKLE_DIS = 1;
 104   1              OUTPUT_EN = 1;
 105   1      
 106   1              set_pwm0(0);
 107   1              set_pwm1(0);
 108   1      
 109   1              uart_write(DEV_NAME, 1);
 110   1              uart_write("START", 5);
 111   1      
 112   1              while(1) {
 113   2                      if(RX_recieved && (RX_BUFFER[0] == '1')) {
 114   3      
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/07/2019 10:34:29 PAGE 3   

 115   3                              if(RX_size == 4 && RX_BUFFER[1] == 'R' ) {
 116   4      
 117   4                                      uart_write(DEV_NAME, 1);
 118   4      
 119   4                                      switch(RX_BUFFER[2]) {
 120   5                                      case 'V':
 121   5                                              uart_write("V", 1);
 122   5                                              uart_write16(poll_adc(VOLTAGE_ADC));
 123   5                                              uart_write("ACK", 3);
 124   5                                              break;
 125   5                                      case 'I':
 126   5                                              uart_write("I", 1);
 127   5                                              uart_write16(poll_adc(CURRENT_ADC));
 128   5                                              uart_write("ACK", 3);
 129   5                                              break;
 130   5                                      case 'T':
 131   5                                              uart_write("T", 1);
 132   5                                              uart_write16(poll_adc(TEMP_ADC));
 133   5                                              uart_write("ACK", 3);
 134   5                                              break;
 135   5                                      }
 136   4                                      RX_recieved = 0;
 137   4                                      RX_size = 0;
 138   4                              }
 139   3                              if(RX_size == 6 && RX_BUFFER[1] == 'T' ) {
 140   4      
 141   4                                      uart_write(DEV_NAME, 1);
 142   4      
 143   4                                      val = (((uint16_t) RX_BUFFER[3]) << 8) & 0xFF00;
 144   4                                      val |= 0x00FF & RX_BUFFER[4];
 145   4                                      switch(RX_BUFFER[2]) {
 146   5                                      case 'V': //NOTE: BE CAREFUL OF OVERFLOW, PWM is 11bits
 147   5                                              uart_write("V", 1);
 148   5                                              set_pwm0(val);
 149   5                                              uart_write16(val);
 150   5                                              uart_write("ACK", 3);
 151   5                                              break;
 152   5                                      case 'I': //NOTE: BE CAREFUL OF OVERFLOW, PWM is 11bits
 153   5                                              uart_write("I", 1);
 154   5                                              //val = val >> 6;
 155   5                                              set_pwm1(val);
 156   5                                              uart_write16(val);
 157   5                                              uart_write("ACK", 3);
 158   5                                              break;
 159   5                                      case 'T':
 160   5                                              uart_write("T", 1);
 161   5                                              if(val == 0) {
 162   6                                                      TRICKLE_DIS = 0;
 163   6                                              } else {
 164   6                                                      TRICKLE_DIS = 1;
 165   6                                              }
 166   5                                              uart_write16(val);
 167   5                                              uart_write("ACK", 3);
 168   5                                              break;
 169   5                                      case 'E':
 170   5                                              uart_write("E", 1);
 171   5                                              if(val == 0) {
 172   6                                                      OUTPUT_EN = 0;
 173   6                                              } else {
 174   6                                                      OUTPUT_EN = 1;
 175   6                                              }
 176   5                                              uart_write16(val);
 177   5                                              uart_write("ACK", 3);
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/07/2019 10:34:29 PAGE 4   

 178   5                                              break;
 179   5                                      }
 180   4                                      RX_recieved = 0;
 181   4                                      RX_size = 0;
 182   4      
 183   4                              }
 184   3                              //uart_write(RX_BUFFER, RX_size);
 185   3      
 186   3                      }
 187   2      
 188   2              }
 189   1      }
 190          
 191          void uart_write16(uint16_t val) {
 192   1              TX_Ready = 0;
 193   1              TX_size = 2;
 194   1              TX_BUFFER[1] = (uint8_t) (val & 0x00FF);
 195   1              SBUF0 = (uint8_t) ((val >> 8) & 0x00FF);
 196   1              while(!TX_Ready);
 197   1      }
 198          
 199          void uart_write(char * buf, uint8_t size) {
 200   1              TX_Ready = 0;
 201   1              TX_size = 0;
 202   1              while((TX_size < size) && (TX_size < UART_BUFFERSIZE)) {
 203   2                      TX_BUFFER[TX_size] = buf[TX_size];
 204   2                      TX_size++;
 205   2              }
 206   1              SBUF0 = TX_BUFFER[0];
 207   1              while(!TX_Ready);
 208   1      }
 209          
 210          void set_pwm0(uint16_t duty) {
 211   1              duty = duty % (1 << 11);
 212   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 213   1      
 214   1         PCA0CPL0 = (duty & 0x00FF);
 215   1         PCA0CPH0 = (duty & 0xFF00)>>8;
 216   1      
 217   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers              // Target PCA0CPH/L regi
             -sters
 218   1      }
 219          
 220          void set_pwm1(uint16_t duty) {
 221   1              duty = duty % (1 << 11);
 222   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 223   1      
 224   1         PCA0CPL1 = (duty & 0x00FF);
 225   1         PCA0CPH1 = (duty & 0xFF00)>>8;
 226   1      
 227   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers
 228   1      }
 229          
 230          
 231          void ADC0_setPositiveInput(ADC0_PositiveInput_t input)
 232          {
 233   1              // Turn on the temp sensor if it is the input
 234   1        if (input == ADC0_POSITIVE_INPUT_TEMP)
 235   1        {
 236   2          REF0CN |= 0x04;
 237   2        }
 238   1        else
 239   1        {
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/07/2019 10:34:29 PAGE 5   

 240   2          REF0CN &= 0xFB;
 241   2        }
 242   1      
 243   1      
 244   1              ADC0MX = input;
 245   1      }
 246          
 247          void ADC0_startConversion(void)
 248          {
 249   1              uint8_t ADCM_save;
 250   1      
 251   1              // Save the conversion source and set to ADBUSY
 252   1              ADCM_save = ADC0CN0 & ADC0CN0_ADCM__FMASK;
 253   1              ADC0CN0 = (ADC0CN0 & ~ADC0CN0_ADCM__FMASK) | ADC0CN0_ADCM__ADBUSY;
 254   1      
 255   1              // Clear the conversion complete flag
 256   1              ADC0CN0_ADINT = 0;
 257   1      
 258   1              // Start a conversion by setting ADBUSY
 259   1              ADC0CN0_ADBUSY = 1;
 260   1      
 261   1              // Restore the conversion source
 262   1              ADC0CN0 |= ADCM_save;
 263   1      }
 264          
 265          bool ADC0_isConversionComplete(void)
 266          {
 267   1              bool conversionComplete;
 268   1              conversionComplete = ADC0CN0_ADINT;
 269   1              return conversionComplete;
 270   1      }
 271          
 272          uint16_t ADC0_getResult(void)
 273          {
 274   1              uint16_t result;
 275   1              result = (0x0FFF & ADC0);
 276   1              return result;
 277   1      }
 278          
 279          //blocking
 280          uint16_t poll_adc(uint16_t channel) {
 281   1              ADC0_setPositiveInput(channel);
 282   1              ADC0_startConversion();
 283   1              while(!ADC0_isConversionComplete());
 284   1              return ADC0_getResult();
 285   1      }
 286          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    475    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

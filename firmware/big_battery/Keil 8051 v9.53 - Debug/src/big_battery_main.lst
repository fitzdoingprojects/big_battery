C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/05/2019 18:03:19 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE BIG_BATTERY_MAIN
OBJECT MODULE PLACED IN .\src/big_battery_main.OBJ
COMPILER INVOKED BY: Z:\home\fitz\Downloads\SimplicityStudio_v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe /media/f
                    -itz/data/dropbox/projects/ee/big_battery/firmware/big_battery/src/big_battery_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(L
                    -ARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SIZE) INTVECTOR(0X0000) INTPROMOTE INCDIR(/media/fitz/data/dropbox/projec
                    -ts/ee/big_battery/firmware/big_battery/inc;/home/fitz/Downloads/SimplicityStudio_v4/developer/sdks/8051/v4.1.5//Device/s
                    -hared/si8051Base;/home/fitz/Downloads/SimplicityStudio_v4/developer/sdks/8051/v4.1.5//Device/EFM8BB1/inc) PRINT(.\src/bi
                    -g_battery_main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/big_battery_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/big_battery_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
  13          #include "InitDevice.h"
  14          // $[Generated Includes]
  15          // [Generated Includes]$
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global CONSTANTS
  19          //-----------------------------------------------------------------------------
  20          #define DEV_NAME "1"
  21          
  22          
  23          SI_SBIT(TRICKLE_DIS, SFR_P0, 2);               // P0.2 Trickle Disable
  24          SI_SBIT(OUTPUT_EN, SFR_P0, 7);               // P0.7 Output Enable
  25          
  26          typedef enum {
  27              ADC0_POSITIVE_INPUT_P0, //!< ADC0P0 is ADC Positive Input
  28              ADC0_POSITIVE_INPUT_P1, //!< ADC0P1 is ADC Positive Input
  29              ADC0_POSITIVE_INPUT_P2, //!< ADC0P2 is ADC Positive Input
  30              ADC0_POSITIVE_INPUT_P3, //!< ADC0P3 is ADC Positive Input
  31              ADC0_POSITIVE_INPUT_P4, //!< ADC0P4 is ADC Positive Input
  32              ADC0_POSITIVE_INPUT_P5, //!< ADC0P5 is ADC Positive Input
  33              ADC0_POSITIVE_INPUT_P6, //!< ADC0P6 is ADC Positive Input
  34              ADC0_POSITIVE_INPUT_P7, //!< ADC0P7 is ADC Positive Input
  35              ADC0_POSITIVE_INPUT_P8, //!< ADC0P8 is ADC Positive Input
  36              ADC0_POSITIVE_INPUT_P9, //!< ADC0P9 is ADC Positive Input
  37              ADC0_POSITIVE_INPUT_P10, //!< ADC0P10 is ADC Positive Input
  38              ADC0_POSITIVE_INPUT_P11, //!< ADC0P11 is ADC Positive Input
  39              ADC0_POSITIVE_INPUT_P12, //!< ADC0P12 is ADC Positive Input
  40              ADC0_POSITIVE_INPUT_P13, //!< ADC0P13 is ADC Positive Input
  41              ADC0_POSITIVE_INPUT_P14, //!< ADC0P14 is ADC Positive Input
  42              ADC0_POSITIVE_INPUT_P15, //!< ADC0P15 is ADC Positive Input
  43              ADC0_POSITIVE_INPUT_TEMP, //!< Internal Temperature Sensor is ADC Positive Input
  44              ADC0_POSITIVE_INPUT_LDO_OUT, //!< Internal 1.8 V LDO Output is ADC Positive Input
  45              ADC0_POSITIVE_INPUT_VDD, //!< VDD Supply Pin is ADC Positive Input
  46              ADC0_POSITIVE_INPUT_GND, //!< GND Supply Pin is ADC Positive Input
  47              ADC0_POSITIVE_INPUT_NONE = 31, //!< ADC Positive Input is disconnected
  48          }ADC0_PositiveInput_t;
  49          
  50          #define VOLTAGE_ADC ADC0_POSITIVE_INPUT_P0
  51          #define CURRENT_ADC ADC0_POSITIVE_INPUT_P1
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/05/2019 18:03:19 PAGE 2   

  52          #define TEMP_ADC ADC0_POSITIVE_INPUT_TEMP
  53          
  54          //-----------------------------------------------------------------------------
  55          // Externs
  56          //-----------------------------------------------------------------------------
  57          extern uint8_t TX_BUFFER[UART_BUFFERSIZE];
  58          extern uint8_t RX_BUFFER[UART_BUFFERSIZE];
  59          extern uint8_t TX_index;
  60          extern uint8_t TX_size;
  61          extern uint8_t RX_size;
  62          extern uint8_t RX_recieved;
  63          extern uint8_t UART_Output_First;
  64          extern uint8_t TX_Ready;
  65          extern uint8_t Byte;
  66          
  67          void uart_write(char * buf, uint8_t size);
  68          void uart_write16(uint16_t val);
  69          void set_pwm0(uint16_t duty);
  70          void set_pwm1(uint16_t duty);
  71          uint16_t poll_adc(uint16_t channel);
  72          
  73          uint16_t ADC0_getResult(void);
  74          bool ADC0_isConversionComplete(void);
  75          void ADC0_startConversion(void);
  76          void ADC0_setPositiveInput(ADC0_PositiveInput_t input);
  77          
  78          
  79          
  80          
  81          //-----------------------------------------------------------------------------
  82          // SiLabs_Startup() Routine
  83          // ----------------------------------------------------------------------------
  84          // This function is called immediately after reset, before the initialization
  85          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  86          // useful place to disable the watchdog timer, which is enable by default
  87          // and may trigger before main() in some instances.
  88          //-----------------------------------------------------------------------------
  89          void SiLabs_Startup (void)
  90          {
  91   1        // $[SiLabs Startup]
  92   1        // [SiLabs Startup]$
  93   1      }
  94          
  95          //-----------------------------------------------------------------------------
  96          // main() Routine
  97          // ----------------------------------------------------------------------------
  98          int main (void) {
  99   1              // Call hardware initialization routine
 100   1              uint16_t val = 0;
 101   1              enter_DefaultMode_from_RESET();
 102   1      
 103   1              TRICKLE_DIS = 1;
 104   1              OUTPUT_EN = 1;
 105   1      
 106   1              set_pwm0(0);
 107   1              set_pwm1(0);
 108   1      
 109   1              uart_write(DEV_NAME, 1);
 110   1              uart_write("\nSTART\n", 5);
 111   1      
 112   1              while(1) {
 113   2                      if(RX_recieved && RX_BUFFER[0]) {
 114   3      
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/05/2019 18:03:19 PAGE 3   

 115   3                              if(RX_size == 4 && RX_BUFFER[1] == 'R' ) {
 116   4      
 117   4                                      uart_write(DEV_NAME, 1);
 118   4      
 119   4                                      switch(RX_BUFFER[2]) {
 120   5                                      case 'V':
 121   5                                              uart_write("V", 1);
 122   5                                              uart_write16(poll_adc(VOLTAGE_ADC));
 123   5                                              uart_write("ACK", 5);
 124   5                                              break;
 125   5                                      case 'I':
 126   5                                              uart_write("I", 1);
 127   5                                              uart_write16(poll_adc(CURRENT_ADC));
 128   5                                              uart_write("ACK", 5);
 129   5                                              break;
 130   5                                      case 'T':
 131   5                                              uart_write("T", 1);
 132   5                                              uart_write16(poll_adc(TEMP_ADC));
 133   5                                              uart_write("ACK", 5);
 134   5                                              break;
 135   5                                      }
 136   4                                      RX_recieved = 0;
 137   4                                      RX_size = 0;
 138   4                              }
 139   3                              if(RX_size == 6 && RX_BUFFER[1] == 'T' ) {
 140   4      
 141   4                                      uart_write(DEV_NAME, 1);
 142   4      
 143   4                                      val = (((uint16_t) RX_BUFFER[3]) << 8) & 0xFF00;
 144   4                                      val |= 0x00FF & RX_BUFFER[4];
 145   4                                      switch(RX_BUFFER[2]) {
 146   5                                      case 'V': //NOTE: BE CAREFUL OF OVERFLOW, PWM is 11bits
 147   5                                              set_pwm0(val);
 148   5                                              uart_write16(val);
 149   5                                              uart_write("ACK", 5);
 150   5                                              break; //NOTE: BE CAREFUL OF OVERFLOW, PWM is 11bits
 151   5                                      case 'I':
 152   5                                              val = val >> 6;
 153   5                                              set_pwm1(val);
 154   5                                              uart_write16(val);
 155   5                                              uart_write("ACK", 5);
 156   5                                              break;
 157   5                                      case 'T':
 158   5                                              if(val == 0) {
 159   6                                                      TRICKLE_DIS = 0;
 160   6                                              } else {
 161   6                                                      TRICKLE_DIS = 1;
 162   6                                              }
 163   5                                              uart_write("ACK", 5);
 164   5                                              break;
 165   5                                      case 'E':
 166   5                                              if(val == 0) {
 167   6                                                      OUTPUT_EN = 0;
 168   6                                              } else {
 169   6                                                      OUTPUT_EN = 1;
 170   6                                              }
 171   5                                              uart_write("ACK", 5);
 172   5                                              break;
 173   5                                      }
 174   4                                      RX_recieved = 0;
 175   4                                      RX_size = 0;
 176   4                              }
 177   3                              //uart_write(RX_BUFFER, RX_size);
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/05/2019 18:03:19 PAGE 4   

 178   3      
 179   3                      }
 180   2      
 181   2              }
 182   1      }
 183          
 184          void uart_write16(uint16_t val) {
 185   1              TX_Ready = 0;
 186   1              TX_size = 2;
 187   1              TX_BUFFER[1] = (uint8_t) (val & 0x00FF);
 188   1              SBUF0 = (uint8_t) (val >> 8) & 0x00FF;
 189   1              while(!TX_Ready);
 190   1      }
 191          
 192          void uart_write(char * buf, uint8_t size) {
 193   1              TX_Ready = 0;
 194   1              TX_size = 0;
 195   1              while((TX_size < size) && (TX_size < UART_BUFFERSIZE)) {
 196   2                      TX_BUFFER[TX_size] = buf[TX_size];
 197   2                      TX_size++;
 198   2              }
 199   1              SBUF0 = TX_BUFFER[0];
 200   1              while(!TX_Ready);
 201   1      }
 202          
 203          void set_pwm0(uint16_t duty) {
 204   1              duty = duty % (1 << 11);
 205   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 206   1      
 207   1         PCA0CPL0 = (duty & 0x00FF);
 208   1         PCA0CPH0 = (duty & 0xFF00)>>8;
 209   1      
 210   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers              // Target PCA0CPH/L regi
             -sters
 211   1      }
 212          
 213          void set_pwm1(uint16_t duty) {
 214   1              duty = duty % (1 << 11);
 215   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 216   1      
 217   1         PCA0CPL1 = (duty & 0x00FF);
 218   1         PCA0CPH1 = (duty & 0xFF00)>>8;
 219   1      
 220   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers
 221   1      }
 222          
 223          
 224          void ADC0_setPositiveInput(ADC0_PositiveInput_t input)
 225          {
 226   1              // Turn on the temp sensor if it is the input
 227   1        if (input == ADC0_POSITIVE_INPUT_TEMP)
 228   1        {
 229   2          REF0CN |= 0x04;
 230   2        }
 231   1        else
 232   1        {
 233   2          REF0CN &= 0xFB;
 234   2        }
 235   1      
 236   1      
 237   1              ADC0MX = input;
 238   1      }
 239          
C51 COMPILER V9.53.0.0   BIG_BATTERY_MAIN                                                  02/05/2019 18:03:19 PAGE 5   

 240          void ADC0_startConversion(void)
 241          {
 242   1              uint8_t ADCM_save;
 243   1      
 244   1              // Save the conversion source and set to ADBUSY
 245   1              ADCM_save = ADC0CN0 & ADC0CN0_ADCM__FMASK;
 246   1              ADC0CN0 = (ADC0CN0 & ~ADC0CN0_ADCM__FMASK) | ADC0CN0_ADCM__ADBUSY;
 247   1      
 248   1              // Clear the conversion complete flag
 249   1              ADC0CN0_ADINT = 0;
 250   1      
 251   1              // Start a conversion by setting ADBUSY
 252   1              ADC0CN0_ADBUSY = 1;
 253   1      
 254   1              // Restore the conversion source
 255   1              ADC0CN0 |= ADCM_save;
 256   1      }
 257          
 258          bool ADC0_isConversionComplete(void)
 259          {
 260   1              bool conversionComplete;
 261   1              conversionComplete = ADC0CN0_ADINT;
 262   1              return conversionComplete;
 263   1      }
 264          
 265          uint16_t ADC0_getResult(void)
 266          {
 267   1              uint16_t result;
 268   1              result = ADC0;
 269   1              return result;
 270   1      }
 271          
 272          //blocking
 273          uint16_t poll_adc(uint16_t channel) {
 274   1              ADC0_setPositiveInput(channel);
 275   1              ADC0_startConversion();
 276   1              while(!ADC0_isConversionComplete());
 277   1              return ADC0_getResult();
 278   1      }
 279          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    441    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
